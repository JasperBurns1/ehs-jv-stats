    // Sort by column (cycles through: none -> desc -> asc -> none)
    function sortByColumn(stats, columnName, currentState) {
      const newState = currentState === 'none' ? 'desc' : 
                       currentState === 'desc' ? 'asc' : 'none';
      
      if (newState === 'none') {
        return { data: [...originalOrder], state: 'none' }; 
      }

      const sorted = [...stats].sort((a, b) => {
        let valA = a[columnName];
        let valB = b[columnName];

        // Special handling for shooting splits (FG, 3PT, FT)
        if (columnName === 'FG' || columnName === '3PT' || columnName === 'FT' || 
            columnName === 'FG%' || columnName === '3PT%' || columnName === 'FT%') {
          
          const parseShootingStat = (val) => {
            if (!val || typeof val !== 'string') return { made: 0, attempts: 0, pct: 0 };
            
            // Handle both "X-Y" format and percentage format
            if (val.includes('-')) {
              const [made, attempts] = val.split('-').map(v => parseInt(v) || 0);
              return {
                made,
                attempts,
                pct: attempts === 0 ? 0 : (made / attempts)
              };
            } else {
              // Handle percentage format (e.g., "45.6%")
              const pct = parseFloat(val.replace('%', '')) / 100;
              return { made: 0, attempts: 0, pct };
            }
          };

          const statsA = parseShootingStat(valA);
          const statsB = parseShootingStat(valB);

          // If either is 0-0, handle specially
          const aIsZeroZero = statsA.attempts === 0;
          const bIsZeroZero = statsB.attempts === 0;
          
          if (aIsZeroZero && bIsZeroZero) return 0;
          if (aIsZeroZero) return 1;  // Move a to bottom
          if (bIsZeroZero) return -1; // Move b to bottom

          // Compare percentages first
          if (statsA.pct !== statsB.pct) {
            return newState === 'desc' ? 
              statsB.pct - statsA.pct : 
              statsA.pct - statsB.pct;
          }

          // If percentages are equal, compare made shots
          if (statsA.made !== statsB.made) {
            return newState === 'desc' ? 
              statsB.made - statsA.made : 
              statsA.made - statsB.made;
          }

          // If made shots are equal, compare attempts
          return newState === 'desc' ? 
            statsB.attempts - statsA.attempts : 
            statsA.attempts - statsB.attempts;
        }

        // Handle non-shooting stat columns as before
        const numA = parseFloat(String(valA).replace('%', ''));
        const numB = parseFloat(String(valB).replace('%', ''));

        if (!isNaN(numA) && !isNaN(numB)) {
          return newState === 'desc' ? numB - numA : numA - numB;
        }

        const strA = String(valA).toLowerCase();
        const strB = String(valB).toLowerCase();
        return newState === 'desc' ? 
          strB.localeCompare(strA) : 
          strA.localeCompare(strB);
      });

      return { data: sorted, state: newState };
    }